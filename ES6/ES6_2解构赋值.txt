解构赋值：
	解构赋值就是把数组或对象，拆开赋值到变量中。
数组解构（Destructuring）赋值：
	特性：
		1.只要等号两边的模式相同，左边的变量就会被赋予对应的值。
		2.解构不成功，变量的值就等于undefined。
		例：
			let [foo, [[bar], baz]] = [1, [[2], 3]];
			foo // 1
			bar // 2
			baz // 3
		3.不完全解构：
			即等号左边的模式，只匹配一部分的等号右边的数组。
		4.默认值：
		例：
			let [x, y = 'b'] = ['a']; // x='a', y='b'
			function f() {console.log('aaa');}let [x = f()] = [1];//如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
	注：
		事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
对象的解构赋值:
	1.对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
	例：
		let { bar, foo } = { foo: "aaa", bar: "bbb" };
		foo // "aaa"
		bar // "bbb"
	2.变量名与属性名不一致，必须写成下面这样：
		let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
		baz // "aaa"
		解析：
			1.foo是匹配的模式，baz才是变量。
			2.对象的解构赋值是上面形式的简写
	3.用于嵌套结构的对象：
	例：
		let obj = {
		  p: [
			'Hello',
			{ y: 'World' }
		  ]
		};

		let { p: [x, { y }] } = obj;
		x // "Hello"
		y // "World"
	4.默认值：
	例：
		var {x = 3} = {};
		x // 3
		注：
			1.默认值生效的条件是，对象的属性值严格等于undefined。
			2.{}就是undefined。
			例：
				var {x = 3} = {x: null};
				x // null
	注：
		将一个已经声明的变量用于解构赋值，必须非常小心。
		由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
字符串的解构赋值：
	字符串被转换成了一个类似数组的对象：
		const [a, b, c, d, e] = 'hello';
		a // "h"
		b // "e"
		c // "l"
		d // "l"
		e // "o"
	对字符串属性解构：
		类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
	例：
		let {length : len} = 'hello';
		len // 5
数值和布尔值的解构赋值：
	
函数参数的解构赋值：
	例：
	function add([x, y]){
	  return x + y;
	}
	add([1, 2]); // 3
	解析：
		函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。
		对于函数内部的代码来说，它们能感受到的参数就是x和y。
圆括号的使用：
	不能使用圆括号的情况：
	可以使用圆括号的情况：
解构赋值用途：
	...
注：
	1.解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
	
	2.由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
		let { prop: x } = undefined; // TypeError
		let { prop: y } = null; // TypeError
	3.解构解析不一定要用let声明：
		[x,y]=[1,2];y;//2
